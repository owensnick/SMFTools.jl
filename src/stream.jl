

function streambam(bamfile, outfile; T=Int32, verbose=false)
    verbose && println("[SMF]\tStreaming BAM file: $bamfile to $outfile")

    starttime = time()

    io = open(outfile, "w")
    println(io, "#bottom_header")

    pos_buff = 0
    write(io, pos_buff)
    

    reader = open(BAM.Reader, bamfile)
    chroms, totalreads, totalpos = stream_frags(reader, io, T=T)
    @show sum(totalreads), sum(totalpos)
    
    index_table = (chrom=chroms, reads=totalreads, pos=totalpos)#, frags_ec=[totalfrags[i, 2:end] for i = 1:size(totalfrags, 1)])
    display(index_table)
     println("[CFB]\tWriting header:")

    pos_buff = position(io)

    
    ### fields
    # start
    # 2. stop
    # 3. strand_chrom_enc
    # 4. read_index
    # 5. position
    # 6. meth prob
    labels = ["read_index", "position", "meth_prob"]
    println(io, "#paired\t",   false)
    println(io, "#numregions\t",   length(chroms))
    println(io, "#totalfrags\t", sum(totalpos))
    println(io, "#totalecfrags\t", [sum(totalreads)])
    println(io, "#numfields\t", 6)
    println(io, "#fields\t[", join(["start" ; "stop" ; "strand_chrom_enc"; labels], ", "), "]")
    println(io, "#dataencoding\t", T)
    frags    = totalpos
    cumfrags = cumsum(frags)
    fragind  = map((s, e) -> s:e, [0 ; cumfrags[1:end-1]] .+ 1, cumfrags)
    println(io, "#index\t", join(zip(chroms, fragind), ","))
    seekstart(io)
    println(io, "#bottom_header")
    write(io, pos_buff)

    close(io)
    println("[NPM]\tcomplete in ", time() - starttime, " seconds")

end

"""
    streamfrags(bamreader, io; T=Int32, filtfun=validfrag, mlt = 0.0)
    
    Function to stream a BAM file reader `bamreader` and write to io stream `io`.

    BAM entries are filtered by `filtfun` and methylation probabilities are filtered by `mlt`.

    Assumes a Nanopore BAM file generated by guppy with methylation probabilities to a binary file that can be loaded by memory mapping with `T` specifying the data type to store information.


"""
function streamfrags(bamreader, io; T=Int32, filtfun=validfrag, mlt = 0.0)

    ### get chromosome names from the bam header
    chroms = [v["SN"] for v in findall(BAM.header(bamreader), "SQ")]
    chromindex = Dict(chroms[i] => i for i = 1:length(chroms))
    

    
    totalreads = zeros(Int, length(chroms))
    totalpos = zeros(Int, length(chroms))
    
    index = 0
    readid = 1
    for record in Iterators.filter(filtfun, bamreader)
        
        chrom = BAM.refname(record)
        fragstart = leftposition(record)
        fragstop = rightposition(record)
        fragstrand = GenomeFragments.getstrand(record)
        chromind = chromindex[chrom]
        
        ### get methylation probabilities
        pos, mlp = posmlp(record)

        haswritten = false
        for (p, ml) in zip(pos, mlp)
            if ml > mlt
                write(io, T(fragstart))         ### start
                write(io, T(fragstop))          ### stop
                write(io, GenomeFragments.set_strand_chrom_enc(fragstrand, chromind, T))          ### chrom strand enc
                write(io, T(readid))
                write(io, T(p))
                write(io, T(ml))
                totalpos[chromind] += 1
                haswritten=true
            end 
        end
        if haswritten
            totalreads[chromind] += 1
        end
        readid += 1
    end
    chroms, totalreads, totalpos
end

"""
    posmlp(record)

    Retrieve the methylation probabilities for the BAM `record` from the `Mm` and `Ml` fields

    *Warning: currently only returns 6mA methylation probabilities*
    *Warning: currently returns methylation probabilities w.r.t the read not the genome, ie some positions may not match the genome*

"""
function posmlp(record)
    pos = BAM.ispositivestrand(record)
    auxdict = BAM.auxdata(record)
    ml = auxdict["Ml"]::Vector{UInt8}
    
    aln = BAM.alignment(record)
    seq = BAM.sequence(record)
    mli = 1
    
    ### output
    positions = Int[]
    ops = Operation[]
    mlp = Int[]

    
    aln = BAM.alignment(record)
    seq = BAM.sequence(record)
    mli = 1
    
    positions = Int[]
    ops = Operation[]
    mlp = Int[]
  
    @assert first(auxdict["Mm"]) == 'A'
    
    if pos
        @assert length(ml) == (sum(s -> s == DNA_A, seq) + sum(s -> s == DNA_C, seq))
    else

        @assert length(ml) == (sum(s -> s == DNA_T, seq) + sum(s -> s == DNA_G, seq))
    end
    
    
    for i = 1:BAM.seqlength(record)
        
        if (pos && (seq[i] == DNA_A)) || (!pos && (seq[i] == DNA_T))
            k, op = seq2ref(aln, i)
            
            if (op == OP_MATCH) || (op == OP_SEQ_MATCH)
                push!(positions, k)
                push!(mlp, ml[mli])
            end
            mli += 1

        end
    end
    positions, mlp
end