

function streambam(bamfile, outfile; T=Int32, verbose=true)
    verbose && println("[SMF]\tStreaming BAM file: $bamfile to $outfile")

    starttime = time()

    io = open(outfile, "w")
    println(io, "#bottom_header")

    pos_buff = 0
    write(io, pos_buff)
    

    if isfile(string(bamfile, ".bai"))
        reader = open(BAM.Reader, bamfile, index=string(bamfile, ".bai"))
        totalreads = totalreadsindex(reader)
        verbose && println("[SMF]\tTotal reads in BAM file: ", totalreads)
    else
        reader = open(BAM.Reader, bamfile)
        totalreads = -1
    end
    chroms, totalreads, totalpos = streamfrags(reader, io, T=T)
    verbose && println("[SMF]\tStreamed ", sum(totalreads), " fragments from ", length(chroms), " chromosomes")
    
    
    #index_table = (chrom=chroms, reads=totalreads, pos=totalpos)
    
    verbose && println("[SMF]\tWriting header.")

    pos_buff = position(io)

    
    ### fields
    # start
    # 2. stop
    # 3. strand_chrom_enc
    # 4. read_index
    # 5. position
    # 6. meth prob
    labels = ["read_index", "position", "meth_prob"]
    println(io, "#paired\t",   false)
    println(io, "#numregions\t",   length(chroms))
    println(io, "#totalfrags\t", sum(totalpos))
    println(io, "#totalecfrags\t", [sum(totalreads)])
    println(io, "#numfields\t", 6)
    println(io, "#fields\t[", join(["start" ; "stop" ; "strand_chrom_enc"; labels], ", "), "]")
    println(io, "#dataencoding\t", T)
    frags    = totalpos
    cumfrags = cumsum(frags)
    fragind  = map((s, e) -> s:e, [0 ; cumfrags[1:end-1]] .+ 1, cumfrags)
    println(io, "#index\t", join(zip(chroms, fragind), ","))
    seekstart(io)
    println(io, "#bottom_header")
    write(io, pos_buff)

    close(io)
    verbose && println("[SMF]\tcomplete in ", time() - starttime, " seconds")

end


"""
    validfrag(record)

    Function to filter BAM `record` to ensure it has an `Ml` field and is not a secondary alignment.
"""
function validfrag(record)
    f = BAM.flag(record)
    
    if BAM.ismapped(record) && haskey(record, "Ml") && ((f == 0) || (f == 16))
        return true
    else
        return false
    end
    
end

"""
    totalreadsindex(reader)

    Function to get the total number of reads in a BAM file reader `reader` using the index
"""
function totalreadsindex(reader)
    if isnothing(reader.index)
        return -1
    else
        return mapreduce(d -> d[end].n_mapped, +, reader.index.index.data) + reader.index.n_no_coors
    end

end

"""
    streamfrags(bamreader, io; T=Int32, filtfun=validfrag, mlt = 0.0)
    
    Function to stream a BAM file reader `bamreader` and write to io stream `io`.

    BAM entries are filtered by `filtfun` and methylation probabilities are filtered by `mlt`.

    Assumes a Nanopore BAM file generated by guppy with methylation probabilities to a binary file that can be loaded by memory mapping with `T` specifying the data type to store information.

"""
function streamfrags(bamreader, io; T=Int32, filtfun=validfrag, mlt = 0.0)

    ### get chromosome names from the bam header
    chroms = [v["SN"] for v in findall(BAM.header(bamreader), "SQ")]
    chromindex = Dict(chroms[i] => i for i = 1:length(chroms))
    

    
    totalreads = zeros(Int, length(chroms))
    totalpos = zeros(Int, length(chroms))
    
    index = 0
    readid = 1

    total_reads_in_file = totalreadsindex(bamreader)
    if total_reads_in_file != -1
        p = Progress(total_reads_in_file, 1, "Streaming BAM file: ", 50)
    else
        p = nothing
    end

    for record in bamreader
        !isnothing(p) && next!(p)
        !filtfun(record) && continue
        
        chrom = BAM.refname(record)
        fragstart = BAM.leftposition(record)
        fragstop = BAM.rightposition(record)
        fragstrand = GenomeFragments.getstrand(record)
        chromind = chromindex[chrom]
        
        ### get methylation probabilities
        pos, mlp = posmlp(record)

        haswritten = false
        for (p, ml) in zip(pos, mlp)
            ### reads with zero mehtylated bases will currently not appear in the output
            if ml > mlt
                write(io, T(fragstart))         ### start
                write(io, T(fragstop))          ### stop
                write(io, GenomeFragments.set_strand_chrom_enc(fragstrand, chromind, T))          ### chrom strand enc
                write(io, T(readid)) ## read index
                write(io, T(p)) ## position
                write(io, T(ml)) ## methylation probability
                totalpos[chromind] += 1
                haswritten=true
            end 
        end
        if haswritten
            totalreads[chromind] += 1
        end
        readid += 1
    end
    chroms, totalreads, totalpos
end

"""
    posmlp(record)

    Retrieve the methylation probabilities for the BAM `record` from the `Mm` and `Ml` fields

    *Warning: currently only returns 6mA methylation probabilities*
    *Warning: currently returns methylation probabilities w.r.t the read not the genome, ie some positions may not match the genome*

"""
function posmlp(record)
    pos = BAM.ispositivestrand(record)
    auxdict = BAM.auxdata(record)
    ml = auxdict["Ml"]::Vector{UInt8}
    
    aln = BAM.alignment(record)
    seq = BAM.sequence(record)
    mli = 1
    
    ### output
    positions = Int[]
    ops = Operation[]
    mlp = Int[]

    
    aln = BAM.alignment(record)
    seq = BAM.sequence(record)
    mli = 1
    
    positions = Int[]
    ops = Operation[]
    mlp = Int[]
  
    @assert first(auxdict["Mm"]) == 'A'
    
    if pos
        @assert length(ml) == (sum(s -> s == DNA_A, seq) + sum(s -> s == DNA_C, seq))
    else

        @assert length(ml) == (sum(s -> s == DNA_T, seq) + sum(s -> s == DNA_G, seq))
    end
    
    
    for i = 1:BAM.seqlength(record)
        if (pos && (seq[i] == DNA_A)) || (!pos && (seq[i] == DNA_T))
            k, op = seq2ref(aln, i)
            
            if (op == OP_MATCH) || (op == OP_SEQ_MATCH)
                push!(positions, k)
                push!(mlp, ml[mli])
            end
            mli += 1

        end
    end
    positions, mlp
end